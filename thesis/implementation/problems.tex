\begin{enumerate}
  \item Rysowanie za pomocą zdarzeń, synchronizacja i buforowanie
  \label{rendering_events}
  \item Znikający \emph{focus} okna aplikacji
  \label{problems_focus}
  \item Kody znaków klawiatury
  \label{problems_keyboard}
  \item ....
  \item problem z clippingiem w przeglądarkach
\end{enumerate}

Ad.\ref{rendering_events} Rysowanie widgetów we frameworku \emph{Qt} realizowane jest wewnątrz kolejki zdarzeń aplikacji. Zdarzenie rysowania powiadamia element interfejsu o konieczności przerysowania. Widget posiada wskaźnik do miejsca w pamięci gdzie powinien przeprowadzic operację renderowania, gdyż sam jest implementacją klasy QPaintDevice. 

Powyższy schemat działania wymagał znalezienia sposobu na zmuszenie widgetów do rysowania za pomocą specjalnie przygotowanej implementacji klasy QPaintEngine oraz QPaintDevice. Do tego celu wykorzystana została metoda biblioteki Qt:

\begin{lstlisting}[language=C++,numbers=none]
void QWidget::render(QPainter * painter, 
                     const QPoint & targetOffset = QPoint(), 
                     const QRegion & sourceRegion = QRegion(), 
                     RenderFlags renderFlags 
                          = RenderFlags(DrawWindowBackground | 
                                        DrawChildren))
\end{lstlisting}

Umożliwiła nam ona wskazanie obiektu QPainter wykorzystującego mechanizm renderowania serwera, tj. reimplementacje klasy QPaintEngine oraz QPaintDevice. Wykorzystanie tej metody powoduje wygenerowanie kolejnego zdarzenia i umieszczenie go w kolejce aplikacji. Powodowało to problem wpadania serwera w nieskończoną pętlę i uniemożliwiało jego dalsze poprawne funkcjonowanie. 

Rozwiązaniem problemu było stworzenie własnej kolejki widgetów, które wymagają renderowania. Kolejka ta jest opróżniana w pewnych odstępach czasu nie krótszych niż 100 milisekund. Wartość ta została dobrana eksperymentalnie tak aby uzyskać efekt płynnej interakcji z aplikacją.

Ad.\ref{problems_focus} Biblioteka \emph{Qt} stanowi niejako nakładkę dla natywnego zarządcy okien systemu operacyjnego. W zwizku z tym o kolejności okien na stosie decyduje system operacyjny. \emph{Qt} podejmuje jedynie odpowiednie czynności w celu aktualizacji graficznego interfejsu aplikacji w zależności od aktualnego stanu konkretnych okien definiowanego przez system operacyjny. W sytuacji kiedy użytkownik nie prowadzi żadnej intrakcji z systemem operacyjnym a jedynie z aplikacją, mogło by się zdarzyć, że niektóe zdarzenia było by ignorowane przez aplikację. Przykładem takiej sytuacji jest wprowadzanie tekstu na klawiaturze. \emph{Qt} przesyła zdarzenia klawiatury do widgeta, który aktualnie posiada focus w oknie, które znajduje się na szczycie stosu okien w systemie operacyjnym. W momencie kiedy dwóch zdalnych użytkowników uruchomiło by aplikację na tym samym serwerze, zdarzenia jednego użytkownika były by ignorowane ponieważ tylko jedno okno jednej aplikacji może być na szczycie stosu. 

Rozwiązaniem tego problemu była reimplementacja odpowiednich metod \emph{Qt} w celu symulacji zachowania stosu okien systemu operacyjnego wewnątrz samej aplikacji. W rezultacie aplikacja działa tak jakby zawsze była aktywna, dzięki czemu framework \emph{Qt} poprawnie renderuje wszystkie elementy interfejsu użytkownika.

Ad.\ref{problems_keyboard} 
\emph{Qt} dostarcza platformowo niezależny opis kodów znaków klawiatury za pomocą zdefiniowanego typu wyliczeniowego \emph{Qt::Key}\footnote{http://doc.qt.digia.com/qt/qt.html\#Key-enum}. Niestety przeglądarki nie są dobrze ustandaryzowane i ich numeracja klawiszy znacznie różni się nie tylko między samymi platformami ale również między ich wersjami. Dodatkowo przeglądarki często nie wspierają wszystkich klawiszy przez to zakres kodów znaków jest inny niż w przypadku biblioteki \emph{Qt}.

Powyższe problemy wymusiły konieczność zaimplementowania metody konwertującej po stronie klienta kody klawiszy na odpowiadające im wartości typu wyliczeniowego \emph{Qt::Key}.

|| TODO: Jak to Janek zrobił
