\subsection{Kolejka zdarzeń}
Aplikacje z graficznym interfejsem opartym o bibliotekę Qt wykorzystują kolejkę zdarzeń do asynchronicznej komunikacji zarówno między obiektami wewnątrz aplikacji jak i aplikacji z systemem operacyjnym. Wszystkie zdarzenia pochodzące od systemu operacyjnego są zamieniane na wewnętrzne zdarzenia biblioteki Qt aby mogły zostać przetworzone przez aplikację. I tak na przykład zwadzenie XEvent odpowiedzialne za zdarzenia myszy jest zamieniane na zdarzenie QMouseEvent, a zdarzenie XEvent odpowiedzialne za aktywację okna na QFocusEvent. 

Podobny model zastosowany został w projekcie serwera aplikacji do komunikacji klienta z aplikacją uruchomioną na serwerze. Wszystkie zdarzenia generowane przez klienta za pomocą przeglądarki wysyłane są w przedstawionym w sekcji \ref{data_protocol} formacie. Z oczywistych względów dane takie należy przetworzyć aby mogły zostać przetworzone przez aplikację. Do tego celu stworzona została specjalna klasa zajmująca się parsowaniem i konwersją danych wejściowych na obiekty. 

Obiekty takie nie mogą być bezpośrednio przekazane aplikacji ponieważ część implementacji kolejki zdarzeń nie jest dostępna dla programistów ze względów bezpieczeństwa, w związku z czym nie jest możliwa np. kontrola aktywacji okien aplikacji wykorzystując jedynie kolejkę zdarzeń, lecz kontrola taka musi odbywać się poprzez wywoływanie odpowiednich metod biblioteki Qt w określonej kolejności.

W związku z powyższym stworzona została dodatkowa warstwa obsługi zdarzeń, która w reakcji na odbiór zdarzeń pośrednich podejmuje decyzję o przekazaniu ich bezpśrednio do samej aplikacji lub też przejmuje na siebie obowiązek sterowania zachowaniem aplikacji poprzez uruchamianie odpowiednich metod i procedur. 

Taki podział strukturalny modelu zdarzeń umożliwia przede wszystkim łatwą jej modyfikację oraz dodawanie obsługi nowych zdarzeń w przyszłości (np. zdarzenia do obsługi urządzeń z ekranem dotykowym).

\subsection{Buforowanie grafik}
Większość współczesnych aplikacji z graficznym interfejsem użytkownika zawiera pewne elementy jak ikona lub obraz w formacie \emph{PNG} (ang. Portable Network Graphics), których nie da się opisać za pomocą prostych elementów jak linia czy elipsa, lecz trzeba je przesłać w postaci danych binarnych. W przypadku takich aplikacji przy każdej zmianie widgeta zawierającego grafikę następuje ponowne jest narysowanie, a więc ta sama ikona czy obraz \emph{PNG} będzie wykorzystywany wielokrotnie. W przypadku aplikacji działającej na zdalnej maszynie wymagało by to wielkrotne transmitowanie tych samych danych co znacznie zmniejszyło by skuteczność i sens wykorzystania stworzonego protokołu komunikacji.

Problem ten rozwiązano poprzez zastosowanie buforowania obrazów. Każdy taki element najpierw poddawany jest operacji wyznaczania wartości skrótowej (ang. hash value) z wykorzystaniem algorytmu MD5. Klucz ten przesyłany jest w klientowi zamiast właściwych danych obrazka, a sama grafika jest umieszczana w buforze serwera aplikacji. Klient chcąc narysować grafikę pobiera ją z serwera podając w zapytaniu otrzymany klucz. Po pobraniu obrazu serwer usuwa go z pamięci lecz nie zapomina o nim całkowicie. Zapamiętuje bowiem informację o tym, że dany obrazek został już przez klienta pobrany i od tej pory to klient jest odpowiedzialny za ponowne wykorzystanie pobranego wcześniej pliku. Serwer nie umieści ponownie w buforze obrazka o identycznej wartości skrótowej, dopóki klient nie poinformuje serwera, że nie przechowuje już dłużej danej grafiki i w przypadku jej ponownego wykorzystania serwer musi ponownie umieścić plik w buforze. 

Takie rozwiązanie zapewnia:
\begin{itemize}
\item zabezpieczenie przed zapełnieniem bufora serwera,
\item znaczne zmniejszenie transferu danych w aplikacjach wykorzystujących grafiki rastrowe --- przeprowadzone testy wykazały, że szybkość działania aplikacji klienckiej i serwera wzrasta nawet dwukrotnie,
\item możliwość kontroli wielkości bufora przez klienta dzięki możliwości zdalnego czyszczenia pamięci kluczy.
\end{itemize}

\subsection{Wpinanie się do aplikacji Qt i komunikacja z serwerem}
Jednym z głównych założeń projektu jest brak konieczności rekompilacji jakichkolwiek aplikacji i bibliotek, w tym \emph{Qt}. Przy tak postawionym warunku jedyną możliwością wykonywania kodu w aplikacji jest użycie wstrzyknięcie własnej biblioteki DLL (ang. DLL injection). Technika ta jest używana do wykonania kodu wstrzykiwanej biblioteki w miejsce oryginalnego kodu innych bibliotek, które normalnie wywołuje program.

Dogłębna analiza kodu źródłowego biblioteki \emph{Qt} pomogła znaleźć funkcję \emph{qt\_startup\_hook} stworzoną specjalnie do nadpisywania i  wstrzykiwania własnego kodu do programów opartych o \emph{Qt}.
Funkcja ta nie jest opisana w dokumentacji frameworka i poznanie jej możliwe jest tylko poprzez analizę kodu źródłowego \emph{Qt}. Funkcja \emph{qt\_startup\_hook} jest wywołana na końcu konstruktora \emph{QCoreApplication}, którego używa każda aplikacja oparta o \emph{Qt}. W momencie jej wykonania rdzeń aplikacji jest w pełni zainicjalizowany, dzięki czemu możliwe jest jego użycie.

Po wpięciu się do aplikacji instalujemy w niej filtr zdarzeń za pomocą metody \emph{QApplication::installEventFilter}, który ma za zadanie przechwytywanie interesujących nas zdarzeń, szczególnie zdarzenia rysowania.
Do aplikacji jest dodawany wątek obsługujący serwer \emph{Websocket}. Przy użyciu lokalnego gniazda (ang. socket) przesyła do serwera numer portu na którym nasłuchuje, który jest przekazany do klienta. Później połączenie lokalne między aplikacją a serwerem jest nieużywane, ponieważ cała komunikacja z klientem przy użyciu \emph{Websocket} jest bezpośrednia. Taka architektura daje pełną swobodę w dalszym rozwoju projektu. Możliwe jest całkowite rozdzielanie uruchomionej i połączonej aplikacji od serwera, lub odwrotnie -- jej pełna zależność i kontrola przez serwer.