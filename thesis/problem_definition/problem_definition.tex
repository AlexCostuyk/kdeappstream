Przedmiotem pracy jest stworzenie prototypowego serwera oraz klienta HTML5. Zadaniem serwera jest jest udostępnienie usługi uruchamiającej aplikacje oparte o biblioteki \emph{Qt} i KDE. Zdalny dostęp do aplikacji uruchomionej w środowisku serwera jest dostępny poprzez interfejs HTML5 udostępniany przez instancję serwera.

Użytkownik serwisu w celu skorzystania z aplikacji \emph{Qt} zainstalowanej na serwerze wchodzi na odpowiedni adres przy użyciu nowoczesnej przeglądarki internetowej. Następnie wybiera interesujący go program i przejmuje nad nim kontrolę. Jest w stanie wyświetlić program w przeglądarce, który wizualnie odpowiada rzeczywistej instancji uruchomionej na serwerze. Wszystkie akcje myszy oraz klawiatury przechwycone przez przeglądarke są wysyłane do serwera, dzięki czemu użytkownik ma pełną kontrolę nad uruchomioną aplikacją. Należy również zaimplementować odpowiednik menedżera okien (ang. window manager) po stronie klienta, aby udostępnić użytkownikowi funkcjonalność pracy z wieloma oknami --- przesuwanie, rozszerzanie, zamykanie, oraz opcjonalnie minimalizowanie oraz maksymalizowanie.

// TODO: Wymagania (ogólne)
// TODO: Przypadki użycia
// TODO: Zachowanie systemu / software'u
// TODO: Struktura systemu / software'u

Postawione zadanie w głównej mierze polega na rozwiązaniu czterech podstawowych problemów:
\begin{enumerate}
  \item komunikacja między klientem a serwerem,
  \item komunikacja między klientem a aplikacją,
  \item uzyskanie informacji o wyglądzie elementów graficznego interfejsu aplikacji,
  \item symulacja interakcji użytkownika z interfejsem aplikacji.
\end{enumerate}

Na rysunku \ref{fig:arch} przedstawiono ideowy schemat architektury systemu rozwiązującego powyższe kwestie. 
Podstawą projektu jest jego modułowość, która separuje logikę odpowiedzialną za udostępnianie interfejsu WWW inicjującego proces aplikacji Qt od części stanowiącej węzeł komunikacyjny pomiędzy klientem a aplikacją Qt działąjącą po stronie serwera.
Można również zauważyć bardzo wyraźne rozgraniczenie między dwoma kanałami przesyłu danych, które wynika z konieczności umożliwienia korzystania z serwera wielu klientom. 
W dalszej części przedstawiono opisy poszczególnych modułów oraz przepływów danych między różnymi częściami architektury na większym poziomie szczegółowości.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\linewidth]{img/arch}
\caption{Schemat architektury systemu.}
\label{fig:arch}
\end{figure}

\input{problem_definition/communication.tex}

\section{Uzyskanie informacji o wyglądzie elementów graficznego interfejsu aplikacji}
\input{problem_definition/data.tex}

\section{Symulacja interakcji użytkownika z interfejsem aplikacji}
\input{problem_definition/simulation.tex}

\section{Odtwarzanie aplikacji po stronie klienta}
\input{problem_definition/render.tex}

\section{Wewnętrzne przepływy danych w module WebSocket serwera}
\input{problem_definition/server-flow.tex}

\section{Zabezpieczenie serwera}
\label{sec:server-security}
\input{problem_definition/acl.tex}
