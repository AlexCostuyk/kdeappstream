<html>
<head>
<title>
    Websocket client test
</title>
<style type="text/css">
    canvas {
        border: 1px solid black;
    }
</style>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script type="text/javascript">

function debug(msg) {
    if (console)
        console.log(msg);
}

var sessionID = '[PUT_SESSION_ID_HERE]';
var portNumber = [PUT_PORT_NUMBER_HERE];
var verbose = false;

function WSConnector(uri, options) {
    this.wsUri = uri;
    this.options = options;
}

WSConnector.prototype = {
    init:function () {
        var self = this;
        try {
            if (typeof MozWebSocket == 'function')
                WebSocket = MozWebSocket;
            this.websocket = new WebSocket(this.wsUri);
            socket = this.websocket;
            this.websocket.onopen = function () {
                debug('Connected');
            };
            this.websocket.onmessage = function (evt) {
                var data = jQuery.parseJSON(evt.data);
                if (verbose)
                    debug(data);
                qtLogic.input(data);
            };
            this.websocket.onerror = function (evt) {
                debug('Error');
                debug(evt);
            };
            this.websocket.onclose = function (evt) {
                debug('Connection closed.');
            };
        } catch (exception) {
            debug('ERROR: ' + exception);
        }

    },
    helloMessage:function () {
        this.websocket.send(sessionID);
        console.log('sent');
    }
};

function QtLogic() {
    this.widgets = {}
}

QtLogic.prototype = {
    input:function (data) {
        var self = this;
        $.each(data, function (_, value) {
            self.singleInput(value);
        });
    },
    singleInput:function (data) {
        var self = this;
        switch (data.command) {
            case "draw":
                this.drawCommand(data);
                break;
            case "addChild":
                this.addChildCommand(data);
                break;
        }
    },
    addChildCommand:function (data) {
        this.addWidgetChild(data.id, data.child);
    },
    drawCommand:function (data) {
        widgety = this.widgets;
        var widgetData = data.widget;
        var widgetId = widgetData.id;
        this.updateWidget(widgetId, { // store
            w:widgetData.w,
            h:widgetData.h,
            x:widgetData.x,
            y:widgetData.y,
            name:widgetData.name
        });
        var widget = this.getWidget(widgetId);
        var renders = data.render;
        var translation = this.calculateTranslation(widget);
        $.each(renders, function (_, value) {
            canvasDrawer.draw(value, translation);
        });
    },
    getWidget:function (id) {
        if (!this.widgets[id]) {
            this.widgets[id] = {
                id:id,
                parent:null,
                children:[]
            }
        }
        return this.widgets[id];
    },
    updateWidget:function (id, data) {
        $.extend(this.getWidget(id), data);
    },
    addWidgetChild:function (id, childId) {
        var children = this.getWidget(id).children;
        var found = false;
        $.each(children, function (_, child) {
            if (child.id == childId) {
                found = true;
                return false; // break
            }
        });
        if (!found) {
            children.push(this.getWidget(childId));
            this.updateWidget(childId, {parent:this.getWidget(id)});
        }
    },
    calculateTranslation:function (widget) {
        var x = 0, y = 0;
        var parent = widget;
        while (parent) {
            x += parent.x;
            y += parent.y;
            parent = parent.parent;
        }
        return {x:x, y:y};
    }
};

function CanvasDrawer(canvasId) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext("2d");
}

CanvasDrawer.prototype = {
    draw:function (data, translation) {
        var ctx = this.ctx;
        ctx.translate(translation.x, translation.y);
        switch (data.t) {
            case "pixmap":
                this.drawPixmap(data);
                break;
            case "rect":
                this.drawRect(data);
                break;
            case "state":
                this.drawState(data);
                break;
            case "tiledPixmap":
                this.drawTtiledPixmap(data);
                break;
            default:
                //debug(data);
        }
        ctx.translate(-translation.x, -translation.y);

    },
    drawPixmap:function (data) {
        var img = new Image();
        img.src = data.data;
        this.ctx.drawImage(img, data.x, data.y, data.w, data.h);
    },
    drawRect:function (data) {
        this.ctx.lineWidth = 0.2;
        this.ctx.fillRect(data.x, data.y, data.w, data.h);
        this.ctx.strokeRect(data.x, data.y, data.w, data.h);
    },
    drawState:function (data) {
        var brush = data.data.brush;
        var font = data.data.font;
        var pen = data.data.pen;
        var transform = data.data.transform;
        if (pen) this.setupPen(pen);
        if (brush) this.setupBrush(brush);
    },
    drawTtiledPixmap:function (data) {
        var img = new Image();
        img.src = data.pixmap;
        var ctx = this.ctx;
        ctx.drawImage(img, data.rect.x, data.rect.y, data.rect.w, data.rect.h);

    },
    setupBrush:function (brush) {
        var ctx = this.ctx;
        switch (brush.t) {
            case 0: // Qt::NoBrush
                ctx.fillStyle = "rgba(0,0,0,0)"; // no filling
                break;
            case 1: // Qt::SolidPattern
                ctx.fillStyle = brush.color;
                break;

        }
    },
    setupPen:function (pen) {
        var ctx = this.ctx;
        ctx.strokeStyle = pen.color;
        ctx.lineWidth = pen.width;
        ctx.lineJoin = pen.join;
        ctx.miterLimit = pen.miter;
    }
};


//function CreateQt() {
//    this.debugTextArea = document.getElementById("debugTextArea");
//    this.canvas = document.getElementById("canvas");
//    console.log(canvas);
//    this.ctx = canvas.getContext('2d');
//    this.context = this.ctx;
//    this.widgets = {}
//    this.websocket = 1;
//
//    this.debug = function (message) {
//        debugTextArea.value += message + "\n";
//        debugTextArea.scrollTop = debugTextArea.scrollHeight;
//    }
//
//    this.sendMessage = function () {
//        var pseudo = document.getElementById("inputPseudo").value;
//        var msg = document.getElementById("inputText").value;
//        var strToSend = pseudo + ": " + msg;
//        if (websocket != null) {
//            document.getElementById("inputText").value = "";
//            websocket.send(strToSend);
//        }
//    }
//
//    this.initWebsocket = function () {
//        this.wsUri = "ws://localhost:5889";
//        try {
//            if (typeof MozWebSocket == 'function')
//                WebSocket = MozWebSocket;
//
//            this.websocket = new WebSocket(this.wsUri);
//
//            this.websocket.onopen = function (evt) {
//
//                debug("CONNECTED");
//            };
//            this.websocket.onclose = function (evt) {
//                alert('DISCONNECTED');
//                for (var i in evt)
//                    alert(i + ': ' + eval('evt.' + i));
//                debug("DISCONNECTED");
//            };
//            this.websocket.onmessage = function (evt) {
//
//                debug(evt.data);
//            };
//            this.websocket.onerror = function (evt) {
//                debug('ERROR: ');
//                debug(evt.data);
//            };
//            this.websocket.send(sessionID);
//
//        } catch (exception) {
//            debug('ERROR: ' + exception);
//        }
//    }
//
//    this.stopWebsocket = function () {
//        if (websocket)
//            websocket.close();
//    }
//
//    this.checkSocket = function () {
//        if (websocket != null) {
//            var stateStr;
//            switch (websocket.readyState) {
//                case 0:
//                    stateStr = "CONNECTING";
//                    break;
//                case 1:
//                    stateStr = "OPEN";
//                    break;
//                case 2:
//                    stateStr = "CLOSING";
//                    break;
//                case 3:
//                    stateStr = "CLOSED";
//                    break;
//                default:
//                    stateStr = "UNKNOW";
//                    break;
//            }
//            debug("Websocket state = " + websocket.readyState + " ( " + stateStr + " )");
//        } else {
//            debug("Websocket is null");
//        }
//    }
//
//    this.drawEllipse = function (centerX, centerY, width, height) {
//        context.save();
//        context.beginPath();
//        context.moveTo(centerX, centerY - height / 2); // A1
//        context.bezierCurveTo(
//                centerX + width / 2, centerY - height / 2, // C1
//                centerX + width / 2, centerY + height / 2, // C2
//                centerX, centerY + height / 2); // A2
//
//        context.bezierCurveTo(
//                centerX - width / 2, centerY + height / 2, // C3
//                centerX - width / 2, centerY - height / 2, // C4
//                centerX, centerY - height / 2); // A1
//
//        context.fillStyle = "red";
//        context.fill();
//        context.closePath();
//        context.restore();
//    }
//
//    this.Point = function (x, y) {
//        this.x = x;
//        this.y = y;
//    }
//
//    this.drawImage = function (sourcePoint, sourceWidth, sourceHeight, destinationPoint, destinationWidth, destinationHeight, image) {
//        var img = new Image();
//        img.onload = function () {
//            context.drawImage(img, sourcePoint.x, sourcePoint.y, sourceWidth, sourceHeight,
//                    destinationPoint.x, destinationPoint.y, destinationWidth, destinationHeight);
//        }
//        img.src = image;
//    }
//
//    this.drawLine = function (point1, point2) {
//        context.save();
//        context.beginPath();
//        context.moveTo(point1.x, point2.y);
//        context.lineTo(point1.x, point2.y);
//        context.closePath();
//        context.stroke();
//        context.restore();
//    }
//
//    this.drawPath = function (path) {
//
//    }
//
//    this.drawPoint = function (point) {
//        context.fillRect(point.x, point.y, 1, 1);
//        context.fill();
//    }
//
//    this.drawPolygon = function (points) {
//        context.save();
//        context.beginPath();
//        context.moveTo(points[0].x, points[0].y);
//        for (var i = 1; i < array.length; i++) {
//            context.lineTo(array[i].x, array[i].y);
//        }
//        context.fill();
//        context.stroke();
//        context.closePath();
//    }
//
//    this.drawRectangle = function (point, width, height) {
//        context.fillRect(point.x, point.y, width, height);
//        context.strokeRect(point.x, point.y, width, height);
//    }
//
//    this.drawText = function (point, text) {
//        context.fillText(text, point.x, point.y);
//    }
//
//    this.addWidget = function (id, parent, point) {
//        widgets[id] = {
//            'parent':parent,
//            'point':point
//        }
//    }
//
//    this.removeWidget = function (id) {
//        delete widgets[id];
//    }
//}


function init() {
    wsConnector = new WSConnector('ws://localhost:' + portNumber);
    qtLogic = new QtLogic();
    canvasDrawer = new CanvasDrawer('canvas');
    wsConnector.init();
}

$(document).ready(function () {
    init();
})

</script>
</head>
<body>
<canvas id="canvas" width="800" height="600">Your browser doesn't support canvas.</canvas>
<div class="data"></div>
</body>
</html>
